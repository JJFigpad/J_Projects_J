//Variables generales
int col = 10;
int fil = 20;
int last = 0;
int c = 0;
int x = 0;
int y = 0; //579
int temph = 0;
int[] limy = new int[10];
boolean cp = true;
boolean pe = false;
//Variables de las figuras
int hor = 0;
int lim1 = 0;
int lim2 = 0;
int tR1 = 0;
int tR2 = 0;
int block1 = 0;
int block2 = 0;
int [] T = {58, 154, 184, 178};
int [] L = {201, 15, 147, 60};
int [] J = {75, 39, 210, 57};
int [] O = {15};
int [] Z = {30, 306, 30, 306};
int [] S = {51, 180, 51, 180};
int [] I = {4369, 3840, 4369, 3840};
int tRotation = 0;
String[] piezas = {"T", "L", "J", "O", "Z", "S", "I"};
String rand;
//Variables del tablero
int[][] tablero = new int[col][fil];
int[] fondox = new int[40];
//int[] fondox = new int[12];


void setup() {
  size(610, 620, P2D);
  background(155, 155, 155);
  Tablero();
  //textSize(20);
}
void draw() {
  push();
  fill(0);
  rect(151, 0, 300, 10);
  pop();
  displayT();
  drawP();
}

void keyPressed() {
  if (key == CODED) {
    if (keyCode == UP && c < 19) {
      if ((tRotation == tR1 && x+hor*30 == block1) || (tRotation == tR2 && x+hor*30 == block2)) {
        tRotation+=0;
      } else {
        tRotation ++;
      }
    }
    tRotation = tRotation < 0 ? 3 : tRotation % 4;
    if (keyCode == DOWN && y+30*c < 579) {
      c++;
    }
    if (keyCode == LEFT && (270+hor*30) >= lim1) {
      hor--;
    } else if (keyCode == RIGHT && (270+hor*30) <= lim2) {
      hor++;
    }
  }
}

//Funciones de las piezas
void sigpieza() {
  if (siguiente() == true) {
    rand = piezas[0]; //int(random(7))
    tRotation = int(random(4));
    hor = 0;
  }
}

Boolean siguiente() {
  if (cp == true) {
    cp = false;
    return true;
  } else if (y+30*c >= 9+(limy[temph])*30) {
    if (millis() >= last+1400) {
      c = -1;
      cp = false;
      pe = true;
      cambioT();
      return true;
    }
  }
  return false;
}

void drawP() {
  sigpieza();
  temph = hor+5;
  if (millis() >= last+1400) {
    c += 1;
    last = millis();
  }
  if (rand == "T") {
    tR1 = 1;
    tR2 = 3;
    block1 = 150;
    block2 = 420;
    push();
    fill(191, 98, 255);
    translate(hor*30, c*30);
    for (int i = 0; i <= 8; i++) {
      if ((T[tRotation] & (1 << 8 - i)) != 0) {
        x = 270+((i % 3) * width / 20);
        y = (((i / 3) | 0) * height / 20)-22;
        rect(x, y, width / 20, height / 20);
      }
    }
    pop();
    if (tRotation == 0 || tRotation == 2) {
      lim1 = 180;
      lim2 = 330;
    } else if (tRotation == 1) {
      lim1 = 150;
      lim2 = 330;
    } else if (tRotation == 3) {
      lim1 = 180;
      lim2 = 360;
    }
  } else if (rand == "L") {
    tR1 = 0;
    tR2 = 2;
    block1 = 181;
    block2 = 181;
    push();
    fill(255, 109, 0);
    translate(hor*30, c*30);
    for (int i = 0; i <= 8; i++) {
      if ((L[tRotation] & (1 << 8 - i)) != 0) {
        x = 270+((i % 3) * width / 20);
        y = (((i / 3) | 0) * height / 20)-22;
        rect(x, y, width / 20, height / 20);
      }
    }
    pop();
    if (tRotation == 0 || tRotation == 2) {
      lim1 = 150;
      lim2 = 330;
    } else if (tRotation == 1 || tRotation == 3) {
      lim1 = 180;
      lim2 = 330;
    }
  } else if (rand == "J") {
    tR1 = 0;
    tR2 = 2;
    block1 = 181;
    block2 = 150;
    push();
    fill(21, 79, 212);
    translate(hor*30, c*30);
    for (int i = 0; i <= 8; i++) {
      if ((J[tRotation] & (1 << 8 - i)) != 0) {
        x = 270+((i % 3) * width / 20);
        y = (((i / 3) | 0) * height / 20)-22;
        rect(x, y, width / 20, height / 20);
      }
    }
    pop();
    if (tRotation == 0 || tRotation == 2) {
      lim1 = 150;
      lim2 = 330;
    } else if (tRotation == 1 || tRotation == 3) {
      lim1 = 180;
      lim2 = 330;
    }
  } else if (rand == "O") {
    push();
    fill(244, 253, 0);
    if (millis() >= last+1500) {
      last = millis();
      c += 1;
    }
    translate(hor*30, c*30);
    for (int i = 0; i <= 3; i++) {
      if ((O[0] & (1 << 3 - i)) != 0) {
        x = 270+((i%2) * width / 20);
        y = (((i / 2) | 0) * height / 20)-22;
        rect(x, y, width / 20, height / 20);
      }
    }
    pop(); 
    lim1 = 180;
    lim2 = 360;
  } else if (rand == "Z") {
    tR1 = 1;
    tR2 = 3;
    block1 = 420;
    block2 = 420;
    push();
    fill(68, 120, 0);
    translate(hor*30, c*30);
    for (int i = 0; i <= 8; i++) {
      if ((Z[tRotation] & (1 << 8 - i)) != 0) {
        x = 270+((i % 3) * width / 20);
        y = (((i / 3) | 0) * height / 20)-22;
        rect(x, y, width / 20, height / 20);
      }
    }
    pop();
    if (tRotation == 0 || tRotation == 2) {
      lim1 = 180;
      lim2 = 330;
    } else if (tRotation == 1 || tRotation == 3) {
      lim1 = 180;
      lim2 = 360;
    }
  } else if (rand == "S") {
    tR1 = 1;
    tR2 = 3;
    block1 = 390;
    block2 = 390;
    push();
    fill(196, 0, 5);
    if (millis() >= last+1500) {
      last = millis();
      c += 1;
    }
    translate(hor*30, c*30);
    for (int i = 0; i <= 8; i++) {
      if ((S[tRotation] & (1 << 8 - i)) != 0) {
        x = 270+((i % 3) * width / 20);
        y = (((i / 3) | 0) * height / 20)-22;
        rect(x, y, width / 20, height / 20);
      }
    }
    pop();
    if (tRotation == 0 || tRotation == 2) {
      lim1 = 180;
      lim2 = 330;
    } else if (tRotation == 1 || tRotation == 3) {
      lim1 = 180;
      lim2 = 360;
    }
  } else if (rand == "I") {
    tR1 = 0;
    tR2 = tR1;
    block1 = 151;
    block2 = 151;
    push();
    fill(0, 204, 204);
    translate(hor*30, c*30);
    for (int i = 0; i <= 15; i++) {
      if ((I[tRotation] & (1 << 15 - i)) != 0) {
        x = 270+((i % 4) * width / 20);
        y = (((i / 4) | 0) * height / 20)-22;
        rect(x, y, width / 20, height / 20);
      }
    }
    pop();
    if (tRotation == 0 || tRotation == 2) {
      lim1 = 90;
      lim2 = 300;
    } else if (tRotation == 1 || tRotation == 3) {
      lim1 = 180;
      lim2 = 300;
      if (x+hor*30 <= 181) {
        hor+=2;
      } else if (x+hor*30 <= 211) {
        hor ++;
      }
    }
  }
  //println(c);
}

//Funciones del tablero
void displayT() {
  strokeWeight(3.5);
  stroke(152, 147, 119);
  pushMatrix();
  translate(151, 9);
  for (int i = 0; i <= col; i ++) {
    line(i*30, 0, i*30, fil*30);
  }
  for (int j = 0; j <= fil; j ++) {
    line(0, j*30, col*30, j*30);
  }
  for (int i = 0; i < col; i ++) {
    for (int j = 0; j < fil; j ++) {
      if (tablero[i][j] == 0) {
        fill(50, 50, 50);
        rect(i*30, j*30, 30, 30);
      } else if (tablero[i][j] == 1) {
        fill(191, 98, 255);
        rect(i*30, j*30, 30, 30);
      }
    }
  }
  popMatrix();
}

void cambioT() {
  if (c < 1 && pe == true) {
    if (rand == "T") {
      if (tRotation == 0) {
        tablero[temph][limy[temph]] = 1;
        tablero[temph][limy[temph]-1] = 1;
        tablero[temph-1][limy[temph]-1] = 1;
        tablero[temph+1][limy[temph]-1] = 1;
        limy[temph]-=2;
        limy[temph+1]-=2;
        limy[temph-1]-=2;
      }
      if (tRotation == 1) {
        tablero[temph][limy[temph]] = 1;
        tablero[temph][limy[temph]-1] = 1;
        tablero[temph][limy[temph]-2] = 1;
        tablero[temph+1][limy[temph]-1] = 1;
        limy[temph]-=3;
        limy[temph+1]-=2;
      }
      if (tRotation == 2) {
        tablero[temph][limy[temph]] = 1;
        tablero[temph][limy[temph]-1] = 1;
        tablero[temph-1][limy[temph]] = 1;
        tablero[temph+1][limy[temph]] = 1;
        limy[temph]-=2;
        limy[temph+1]--;
        limy[temph-1]--;
      }
      if (tRotation == 3) {
        tablero[temph-1][limy[temph]-1] = 1;
        tablero[temph][limy[temph]] = 1;
        tablero[temph][limy[temph]-1] = 1;
        tablero[temph][limy[temph]-2] = 1;
        limy[temph]-=2;
        limy[temph-1]-=3;
      }
    }
  }
  println(temph);
}

void Tablero() {
  for (int i = 0; i < col; i++) {
    for (int j = 0; j < fil; j++) {
      tablero[i][j] = 0;
    }
  }
  for (int i = 0; i < 40; i++) {
    fondox[i] = 0;
  }
  for (int i = 0; i < 10; i++) {
    limy[i] = 19;
  }
}
